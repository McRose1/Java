# IO/NIO

## 阻塞 IO 模型
最传统的一种 IO 模型，即在读写数据过程中会发生阻塞现象。

当用户线程发出 IO 请求之后，内核会去查看数据是否就绪，如果没有就绪就会等待数据就绪，而用户线程就会处于阻塞状态，用户线程交出 CPU。

当数据就绪之后，内核会将数据拷贝到用户线程，并返回结果给用户线程，用户线程才解除 block 状态。

典型的阻塞 IO 模型的例子为：data = socket.read()；如果数据没有就绪，就会一直阻塞在 read 方法。

## 非阻塞 IO 模型
当用户线程发起一个 read 操作后，并不需要等待，而是马上得到了一个结果。

如果结果是一个 error 时，它就知道数据还没有准备好，于是它可以再次发送 read 操作。

一旦内核中的数据准备好了，并且又再次收到了用户线程的请求，那么它马上就将数据拷贝到了用户线程，然后返回。

所以事实上，在非阻塞 IO 模型中，用户线程需要不断地询问内核数据是否就绪，也就是说非阻塞 IO 不会交出 CPU，而会一直占用 CPU。

典型的非阻塞 IO 模型一般如下：
```java
while (true) {
  data = socket.read();
  if (data != error) {
    处理数据
    break;
  }
}
```
但是对于非阻塞 IO 就有一个非常严重的问题，**在 while 循环中需要不断地去询问内核数据是否就绪，这样会导致 CPU 占用率非常高**，一次你一般情况下很少使用 while 循环这种方式来获取数据。

## 多路复用 IO 模型
多路复用 IO 模型是目前使用得比较多的模型。

Java NIO 实际上就是多路复用 IO。

在多路复用 IO 模型中，会有**一个线程不断地去轮询多个 socket 的状态，只有当 socket 真正有读写事件时，才真正调用实际的 IO 读写操作**。

因为在多路复用 IO 模型中，只需要使用一个线程就可以管理多个 socket，系统不需要建立新的进程或者线程，也不必维护这些线程和进程，并且只有在真正有 socket 读写事件进行时，才会使用 IO 资源，所以它大大减少了资源占用。

在 Java NIO 中，是通过 selector.select()去查询每个通道是否有到达事件，如果没有事件，则一直阻塞在那里，因此这种方式会导致用户线程的阻塞。

因此，多路复用 IO 比较适合连接数比较多的情况。

**另外多路复用 IO 为何比非阻塞 IO 模型的效率高是因为在非阻塞 IO 模型中，不断地询问 socket 状态是通过用户线程去进行的，而在多路复用 IO 中，轮询每个 socket 状态是内核在进行的，这个效率要比用户线程要高得多**。

不过要注意的是，多路复用 IO 模型是通过轮询的方式来检测是否有事件到达，并且对到达的时间逐一进行响应。

因此对于多路复用 IO 模型来说，**一旦事件响应体很大，那么就会导致后续的事件迟迟得不到处理，并且会影响新的事件轮询**。






















