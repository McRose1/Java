# Java 23 种设计模式

## 创造型模式

### 工厂方法模式

### 抽象工厂模式（Abstract Factory）

### 单例模式（Singleton）

### 建造者模式

### 原型模式

## 结构型模式

### 适配器模式

### 装饰器模式（Decorator）
在现实生活中国，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。

在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以采用装饰器模式来实现。

定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些指责（即增加其额外功能）的模式。

优点：
- 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
- 通过使用不同装饰类及这些装饰类的排列组合，可以实现不同效果
- 完全遵守开闭原则

缺点：装饰模式会增加许多子类，过度使用会增加程序的复杂性。

#### 结构与实现
通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。

模式的结构：
1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接受附加责任的对象
2. 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些指责
3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任

#### 应用场景：
- 当需要给一个现有的类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类
- 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现
- 当对象的功能要求可以动态地添加，也可以再动态地撤销时

装饰模式在 Java 中最著名的应用莫过于 Java I/O 标准库的设计了。
- InputStream 的子类 FilterInputStream
- OutputStream 的子类 FileterOutputStream
- Reader 的子类 BufferedReader 以及 FilterReader 
- Writer 的子类 BufferedWriter、FilterReader 以及 PrintWriter 

下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：
```java
BufferedReader in = new BufferedReader(new FileReader("filename.txt"));
String s = in.readLine();
```


### 代理模式

### 外观模式

### 桥接模式

### 组合模式

### 享元模式

## 行为型模式

### 策略模式

### 模板方法模式

### 观察者模式

### 迭代子模式

### 责任链模式

### 命令模式

### 备忘录模式

### 状态模式

### 访问者模式

### 中介者模式

### 解释器模式

# 模块耦合关系
根据耦合性从低到高：非直接耦合→数据耦合→标记耦合→控制耦合→外部耦合→公共耦合→内容耦合

写程序提倡模块间耦合度越低越好，也就是模块之间越不相关越好。

## 非直接耦合
两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用实现的。

## 数据耦合
如果一个模块访问另一个模块时，彼此之间是通过数据参数（不是控制参数、公共数据结构或外部变量）来交换输入、输出信息的，则称为数据耦合

## 标记耦合
如果一组模块通过数据结构本身传递

## 控制耦合
如果一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内的某一功能

## 外部耦合
一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息

## 公共耦合
若一组模块都访问同一个公共数据环境

## 内容耦合
若一个模块直接访问另一个模块的内部数据、一个模块不通过正常入口转到另一个模块内部、两个模块有一部分程序代码重叠或者一个模块有多个入口

















