# Java 23 种设计模式

## 创造型模式

### 工厂方法模式

### 抽象工厂模式（Abstract Factory）

### 单例模式（Singleton）

### 建造者模式

### 原型模式

## 结构型模式

### 适配器模式

### 装饰器模式（Decorator）
在现实生活中国，常常需要对现有产品增加新的功能或美化其外观，如房子装修、相片加相框等，都是装饰器模式。

在软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。所有这些都可以采用装饰器模式来实现。

定义：指在不改变现有对象结构的情况下，动态地给该对象增加一些指责（即增加其额外功能）的模式。

优点：
- 装饰器是继承的有力补充，比继承灵活，在不改变原有对象的情况下，动态的给一个对象扩展功能，即插即用
- 通过使用不同装饰类及这些装饰类的排列组合，可以实现不同效果
- 完全遵守开闭原则

缺点：装饰模式会增加许多子类，过度使用会增加程序的复杂性。

#### 结构与实现
通常情况下，扩展一个类的功能会使用继承方式来实现。但继承具有静态特征，耦合度高，并且随着扩展功能的增多，子类会很膨胀。如果使用组合关系来创建一个包装对象（即装饰对象）来包裹真实对象，并在保持真实对象的类结构不变的前提下，为其提供额外的功能，这就是装饰模式的目标。

模式的结构：
1. 抽象构件（Component）角色：定义一个抽象接口以规范准备接受附加责任的对象
2. 具体构件（ConcreteComponent）角色：实现抽象构件，通过装饰角色为其添加一些指责
3. 抽象装饰（Decorator）角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能
4. 具体装饰（ConcreteDecorator）角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任

#### 应用场景：
- 当需要给一个现有的类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类
- 当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现
- 当对象的功能要求可以动态地添加，也可以再动态地撤销时

装饰模式在 Java 中最著名的应用莫过于 Java I/O 标准库的设计了。
- InputStream 的子类 FilterInputStream
- OutputStream 的子类 FileterOutputStream
- Reader 的子类 BufferedReader 以及 FilterReader 
- Writer 的子类 BufferedWriter、FilterReader 以及 PrintWriter 

下面代码是为 FileReader 增加缓冲区而采用的装饰类 BufferedReader 的例子：
```java
BufferedReader in = new BufferedReader(new FileReader("filename.txt"));
String s = in.readLine();
```

---

### 代理模式（Proxy）
在某些情况下，一个客户不能活着不想直接访问另一个对象，这是需要找一个中介帮忙完成某项任务，这个中介就是代理对象。例如，购买火车票不一定要去火车站买，可以通过12306网站活着火车票代售点买。又比如找女朋友、找保姆、找工作都可以通过找中介完成。

在软件设计中，使用代理模式的例子也很多，例如，要访问的远程对象比较大（如视频或大图像等），其下载要花很多时间。还有因为安全原因需要屏蔽客户端直接访问真实对象，如某单位的内部数据库等。

#### 定义和特点
代理模式：由于某些原因需要给某对象提供一个代理以控制对该对象的访问。这时，访问对象不适合或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。

优点：
- 代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用
- 代理对象可以扩展目标对象的功能
- 代理模式能将客户端与目标对象分离，在一定程度上降低了系统的耦合度，增加了程序的可扩展性

缺点：
- 代理模式会造成系统设计中类的数量增加
- 在客户端和目标对象之间增加一个代理对象，会造成请求处理速度变慢
- 增加了系统的复杂度

如何解决上述缺点？➡️ 动态代理

#### 结构
1. 抽象主题（Subject）类：通过借口或抽象类声明真实主题和代理对象实现的业务方法
2. 真实主题（Real Subject）类：实现了抽象主题中的具体业务，是代理对象所代表的真实对象，是最终要引用的对象
3. 代理（Proxy）类：提供了与真实主题相同的接口，其内部含有对真实主题的引用，它可以访问、控制或扩展真实主题的功能

在代理的创建时期，




### 外观模式（Facade）
在现实生活中，常常存在办事较复杂的例子，如办房产证或注册一家公司，有时要同多个部门联系，这时要是有一个综合部门能解决一切手续问题就好了。

软件设计也是这样，当一个系统的功能越来越强。子系统会越来越多，客户对系统的访问也变得越来越复杂。这时如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特法则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。

#### 定义和特点
外观模式：又叫做门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。

在日常编码中，我们都在有意无意的大量使用外观模式。只要是高层模块需要调度多个子系统（2个以上的类对象），我们都会自觉地创建一个新的类封装这些子系统，提供精简的接口，让高层模块可以更加容易的间接调用这些子系统的功能。尤其是现阶段各种第三方SDK、开源类库，很大概率都会使用外观模式。

外观模式是“迪米特法则”的典型应用。

优点：
1. 降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。
2. 对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。
3. 降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。

缺点：
1. 不能很好地限制客户使用子系统类，很容易带来未知风险。
2. 增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭法则”。

#### 结构
1. 外观（Facade）角色：为多个子系统对外提供一个共同的接口。
2. 子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。
3. 客户（Client）角色：通过一个外观角色访问各个子系统的功能。

### 桥接模式（Bridge）
在现实生活中，某些类具有 2 个或多个维度的变化，如图形既可按形状分，又可按颜色分。如何设计类似 PS 这样的软件，能画出不同形状和不同颜色的图形呢？如果用继承方式，m 种形状和 n 种颜色的图形就有 mxn 种，不但对应的子类很多，而且扩展困难。

#### 定义和特点
桥接模式：**将抽象与实现抽象，使它们可以独立变化**。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。

桥接模式遵循了里氏替换原则和依赖倒置原则，最终实现了开闭原则，对修改关闭，对扩展开发。

优点：
- 抽象与实现分离，扩展能力强
- 符合开闭原则
- 符合合成复用原则
- 其实现细节对客户透明

缺点：由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编码，能正确地识别出系统中 2 个独立变化的维度，这增加了系统的理解与设计难度。

#### 结构
1. 抽象化（Abstraction）角色：定义抽象类，并包含一个对实现化对象的引用
2. 扩展抽象化（Refined Abstraction）角色：是抽象类角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。
3. 实现化（Implementor）角色：定义实现化角色的接口，供扩展抽象化角色调用
4. 具体实现化（Concrete Implementor）角色：给出实现化角色接口的具体实现

#### 应用实例

---

### 组合模式（Composite）
在现实生活中，存在很多“部分-整体”的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品种的衣服与衣柜以及厨房中的锅碗瓢盆等。

在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。

#### 定义与特点
组合模式：又叫做部分-整体模式，它是一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。

优点：
1. 组合模式使得客户端代码可以一致的处理单个对象和组合对象，无需关心自己处理的是单个对象，还是组合对象，这简化了客户端代码。
2. 更容易在组合体内加入新的对象，客户端不会因为加入了新的对象而更改源代码，满足“开闭原则”。

缺点：
1. 设计较复杂，客户端需要花更多时间理清类之间的层次关系。
2. 不容易限制容器中的构件。
3. 不容易用继承的方法来增加构件的新功能。

#### 结构
1. 抽象构件（Component）角色：它的主要作用是为树叶构件和树枝构件声明公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝构件完成。
2. 树叶构件（Leaf）角色：是组合中的叶节点对象，它没有子节点，用于实现抽象构件角色中声明的公共接口。
3. 树枝构件（Composite）角色：是组合中的分支节点对象，它有子节点。它实现了抽象构件角色中声明的接口，它的主要作用是存储和管理子部件，通常包含Add()、Remove()、GetChild()等方法。

组合模式分为透明式的组合模式和安全式的组合模式：
1. 透明方式：在该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无需区别树叶对象和树枝对象，对客户端来说是透明的。但其缺点是：树叶构件本来没有Add()、Remove()、GetChild()方法，却要实现它们（空实现或抛异常），这样会带来一些安全性问题。
2. 安全方式：在该方式中，将管理子构件的方法移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式的安全性问题，但由于叶子和分支有不同的接口，客户端在调用时要知道树叶对象和树枝对象的存在，所以失去了透明性。

### 享元模式

## 行为型模式

### 策略模式

### 模板方法模式

### 观察者模式

### 迭代子模式

### 责任链模式

### 命令模式

### 备忘录模式

### 状态模式

### 访问者模式

### 中介者模式

### 解释器模式

# 模块耦合关系
根据耦合性从低到高：非直接耦合→数据耦合→标记耦合→控制耦合→外部耦合→公共耦合→内容耦合

写程序提倡模块间耦合度越低越好，也就是模块之间越不相关越好。

## 非直接耦合
两个模块之间没有直接关系，它们之间的联系完全是通过主模块的控制和调用实现的。

## 数据耦合
如果一个模块访问另一个模块时，彼此之间是通过数据参数（不是控制参数、公共数据结构或外部变量）来交换输入、输出信息的，则称为数据耦合

## 标记耦合
如果一组模块通过数据结构本身传递

## 控制耦合
如果一个模块调用另一个模块时，传递的是控制变量（如开关、标志等），被调模块通过该控制变量的值有选择地执行块内的某一功能

## 外部耦合
一组模块都访问同一全局简单变量，而且不通过参数表传递该全局变量的信息

## 公共耦合
若一组模块都访问同一个公共数据环境

## 内容耦合
若一个模块直接访问另一个模块的内部数据、一个模块不通过正常入口转到另一个模块内部、两个模块有一部分程序代码重叠或者一个模块有多个入口

















