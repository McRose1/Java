# JVM
## 基本概念
JVM 是可运行 Java 代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域。

JVM 是运行在操作系统之上的，它与硬件没有直接的交互。

## 运行过程
Java 源文件通过编译器，能够产生相应的 .class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。

① Java 源文件 -> 编译器 -> 字节码文件

② 字节码文件 -> JVM -> 机器码

每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了，当一个程序从开始运行，这时虚拟机就开始虚拟化了，多个程序启动就会存在多个虚拟机实例。

程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不同共享。

## JVM 运行时内存
Java 堆从 GC 的角度还可以细分为：
- 新生代
  - Eden 区
  - From Survivor 区
  - To Survivor 区
- 老年代

## 新生代
是用来存放新生的对象。一般占据堆的 1/3 空间。

由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。

### Eden 区
**Java 新对象的出生地**（如果新创建的对象占用内存很大，则直接分配到老年代）。

当 Eden 区内存不够的时候就会触发 MinorGC，对新生代进行一次垃圾回收。

### SurvivorFrom
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

### SurvivorTo
保留了一次 MinorGC 过程中的幸存者

### MinorGC 的过程（复制 -> 清空 -> 互换）
MinorGC 采用**复制算法**。

1. Eden, SurvivorFrom 复制到 SurvivorTo，年龄+1
首先，把 Eden 区和 SurvivorFrom 区域中存活的对象复制到 SurvivorTo 区域（如果有对象的年龄已经达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果 SurvivorTo 不够位置了就放到老年区）
2. 清空 Eden，SurvivorFrom
然后，情况 Eden 和 SurvivorFrom 中的对象
3. SurvivorTo 和 SurvivorFrom 互换
最后，SurvivorTo 和 SurvivorFrom 互换，原 SurvivorTo 成为下一次 GC 的 SurvivorFrom 区。

## 老年代
主要存放应用程序中生命周期长的内存对象。

老年代的对象比较稳定，所以 MajorGC 不会频繁执行。

在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。

当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

MajorGC 采用**标记清除算法**：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。

MajorGC 的耗时比较长，因为要扫描再回收。

MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。

当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。

## 永久代
指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息，Class 在被加载的时候被放入永久区域，它和存放实例的区域不同，GC 不会在主程序运行期对永久区域进行清理。

所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常.

## Java8 与元数据
在 Java8 中,**永久代已经被移除,被一个称为“元数据区”（元空间）的区域所取代**。

元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。

因此，默认情况下，元空间的大小仅受本地内存限制。

**类的元数据放入 native memory，字符串池和类的静态变量放入 Java 堆中**，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。

























