# JVM
## 基本概念
JVM 是可运行 Java 代码的假想计算机，包括一套字节码指令集、一组寄存器、一个栈、一个垃圾回收、堆和一个存储方法域。

JVM 是运行在操作系统之上的，它与硬件没有直接的交互。

## 运行过程
Java 源文件通过编译器，能够产生相应的 .class 文件，也就是字节码文件，而字节码文件又通过 Java 虚拟机中的解释器，编译成特定机器上的机器码。

① Java 源文件 -> 编译器 -> 字节码文件

② 字节码文件 -> JVM -> 机器码

每一种平台的解释器是不同的，但是实现的虚拟机是相同的，这也就是 Java 为什么能够跨平台的原因了，当一个程序从开始运行，这时虚拟机就开始虚拟化了，多个程序启动就会存在多个虚拟机实例。

程序退出或者关闭，则虚拟机实例消亡，多个虚拟机实例之间数据不同共享。

## JVM 运行时内存
Java 堆从 GC 的角度还可以细分为：
- 新生代
  - Eden 区
  - From Survivor 区
  - To Survivor 区
- 老年代

## 新生代
是用来存放新生的对象。一般占据堆的 1/3 空间。

由于频繁创建对象，所以新生代会频繁触发 MinorGC 进行垃圾回收。

### Eden 区
**Java 新对象的出生地**（如果新创建的对象占用内存很大，则直接分配到老年代）。

当 Eden 区内存不够的时候就会触发 MinorGC，对新生代进行一次垃圾回收。

### SurvivorFrom
上一次 GC 的幸存者，作为这一次 GC 的被扫描者。

### SurvivorTo
保留了一次 MinorGC 过程中的幸存者

### MinorGC 的过程（复制 -> 清空 -> 互换）
MinorGC 采用**复制算法**。

1. Eden, SurvivorFrom 复制到 SurvivorTo，年龄+1
首先，把 Eden 区和 SurvivorFrom 区域中存活的对象复制到 SurvivorTo 区域（如果有对象的年龄已经达到了老年的标准，则复制到老年代区），同时把这些对象的年龄+1（如果 SurvivorTo 不够位置了就放到老年区）
2. 清空 Eden，SurvivorFrom
然后，情况 Eden 和 SurvivorFrom 中的对象
3. SurvivorTo 和 SurvivorFrom 互换
最后，SurvivorTo 和 SurvivorFrom 互换，原 SurvivorTo 成为下一次 GC 的 SurvivorFrom 区。

## 老年代
主要存放应用程序中生命周期长的内存对象。

老年代的对象比较稳定，所以 MajorGC 不会频繁执行。

在进行 MajorGC 前一般都先进行了一次 MinorGC，使得有新生代的对象晋升入老年代，导致空间不够用时才触发。

当无法找到足够大的连续空间分配给新创建的较大对象时也会提前触发一次 MajorGC 进行垃圾回收腾出空间。

MajorGC 采用**标记清除算法**：首先扫描一次所有老年代，标记出存活的对象，然后回收没有标记的对象。

MajorGC 的耗时比较长，因为要扫描再回收。

MajorGC 会产生内存碎片，为了减少内存损耗，我们一般需要进行合并或者标记出来方便下次直接分配。

当老年代也满了装不下的时候，就会抛出 OOM（Out of Memory）异常。

## 永久代
指内存的永久保存区域，主要存放 Class 和 Meta（元数据）的信息，Class 在被加载的时候被放入永久区域，它和存放实例的区域不同，GC 不会在主程序运行期对永久区域进行清理。

所以这也导致了永久代的区域会随着加载的 Class 的增多而胀满，最终抛出 OOM 异常.

## Java8 与元数据
在 Java8 中,**永久代已经被移除,被一个称为“元数据区”（元空间）的区域所取代**。

元空间的本质和永久代类似，元空间与永久代之间最大的区别在于：**元空间并不在虚拟机中，而是使用本地内存**。

因此，默认情况下，元空间的大小仅受本地内存限制。

**类的元数据放入 native memory，字符串池和类的静态变量放入 Java 堆中**，这样可以加载多少类的元数据就不再由 MaxPermSize 控制，而由系统的实际可用空间来控制。

## 垃圾回收算法

如何确定垃圾？
### 引用计数法
在 Java 中，引用和对象是有关联的。如果要操作对象必须用引用进行。

因此，很显然一个简单的方法是通过引用计数来判断一个对象是否可以回收。

简单说，即一个**对象如果没有任何与之关联的引用，即他们的引用计数都为 0，则说明对象不太可能再被用到，那么这个对象就是可回收对象**。

### 可达性分析
为了解决引用计数法的循环引用问题，Java 使用了可达性分析的方法。

通过一系列的“GC roots”对象作为起点搜索。

如果**在“GC roots”和一个对象之间没有可达路径，则称该对象是不可达的**。

要注意的是，不可达对象不等价于可回收对象，**不可达对象变为可回收对象至少需要经过两次标记过程**。

两次标记后仍然是可回收对象，则将面临回收。

### 标记清除算法（Mark-Sweep）
最基础的垃圾回收算法，分为**两个阶段，标记和清除**。

标记阶段标记出所有需要回收的对象，清楚阶段回收被标记的对象所占用的空间。

该算法**最大的问题是内存碎片化严重**，后序可能发生大对象不能找到可利用空间的问题。

### 复制算法（copying）
为了解决 Mark-Sweep 算法内存碎片化的缺陷而被提出的算法。

按内存容量将内存划分为等大小的两块。

每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉。

这种算法虽然实现简单，内存效率高，不易产生碎片，但是最大的问题是可用内存被压缩到了原本的一半。

且存活对象增多的话，copying 算法的效率会大大降低。

### 标记整理算法（Mark-Compact）
结合了以上两个算法，为了避免缺陷而提出。

标记阶段和 Mark-Sweep 算法相同，**标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象**。

### 分代收集算法
分代收集算法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老年代（Tenured/Old Generation）和新生代（Yong Generation）。

老年代的特点是每次垃圾回收时只有少量对象需要被回收，新生代的特点是每次垃圾回收时都有大量垃圾需要被回收，因此可以根据不同区域选择不同的算法。

#### 新生代与复制算法
目前大部分 JVM 的 GC 对于新生代都采用 Copying 算法，因为新生代中每次垃圾回收都要回收大部分对象，即要复制的操作比较少，但通常并不是按照 1:1 来划分新生代。

一般将新生代划分为一块较大的 Eden 空间和两个较小的 Survivor 空间（From Space, To Space），每次使用 Eden 空间和其中一块 Survivor 空间，当进行回收时，将该两块空间中还存活的对象复制到另一块 Survivor 空间中。

#### 老年代与标记整理算法
而老年代因为每次只回收少量对象，因而采用 Mark-Compact 算法。

1. Java 虚拟机提到过的处于**方法区的永生代（Permenant Generation），它用来存储 class 类，常量，方法描述等**。对永生代的回收主要包括废弃常量和无用的类。
2. 对象的内存分配主要在新生代的 Eden Space 和 Survivor Space 的 From Space（Survivor 目前存放对象的那一块），少数情况会直接分配到老年代。
3. 当新生代的 Eden Space 和 From Space 空间不足时就会发生一次 GC,进行 GC 后，Eden Space 和 From Space 区的存活对象会被挪到 To Space，然后将 Eden Space 和 From Space 进行清理。
4. 如果 To Space 无法足够存储某个对象，则将这个对象存储到老年代。
5. 在进行 GC 后，使用的便是 Eden Space 和 To Space 了，如此反复循环。
6. 当对象在 Survivor 区躲过一次 GC 后，其年龄就会+1。**默认情况下年龄达到 15 的对象会被移到老年代中**。

## GC 垃圾收集器

### CMS 收集器（多线程标记清除算法）
Concurrent Mark Sweep（CMS）收集器是一种老年代垃圾收集器，其**最主要目标是获取最短垃圾回收停顿时间**，和其他老年代使用标记-整理算法不同，它使用**多线程的标记-清除算法**。

最短的垃圾收集停顿时间可以为交互比较高的程序提高用户体验。

CMS 工作机制相比其他的垃圾收集器来说更复杂，整个过程分为以下 4 个阶段：

#### 初始标记
只是标记以下 GC Roots 能直接关联的对象，速度很快，仍然需要暂停所有的工作线程。

#### 并发标记
进行 GC Roots 跟踪的过程，和用户线程一起工作，不需要暂停工作线程。

#### 重新标记
为了修正正在并发标记期间，因用户程序继续运行而导致标记产生变动的那一部分对象的标记记录，仍然需要暂停所有的工作线程。

#### 并发清除
清除 GC Roots 不可达对象，和用户线程一起工作，不需要暂停工作线程。

由于耗时最长的并发标记和并发清除过程中，垃圾收集线程可以和用户线程在一起并发工作，**所以总体上来看 CMS 收集器的内存回收和用户线程是一起并发地执行**。

### G1 收集器
Garbage First 垃圾收集器是目前垃圾收集器理论发展的最前沿结果，相比于 CMS 收集器，G1 收集器两个最突出的改进是：
1. 基于标记-整理算法，不产生内存碎片。
2. 可以非常精准控制停顿时间，在不牺牲吞吐量的前提下，实现低停顿垃圾回收。

**G1 收集器避免全区域垃圾收集，它把堆内存划分为大小固定的几个独立区域**，并且跟踪这些区域的垃圾收集进度，同时在后台维护一个优先级列表，每次根据所允许的收集时间，**优先回收垃圾最多的区域**。

区域划分和优先级区域回收机制，确保 G1 收集器可以在有限时间获得最高的垃圾收集效率。












































